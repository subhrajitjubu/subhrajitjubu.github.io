<!DOCTYPE html>
<html>
<head>
    <title>Weather charts</title>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/modules/exporting.js"></script>
    <script src="https://code.highcharts.com/modules/export-data.js"></script>
    <script src="https://code.highcharts.com/modules/accessibility.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- <script src="nasa.js"></script> -->

    <style>
        body {
          display: flex;
          flex-direction: column;
          height: 100vh; /* Full height of the viewport */
          margin: 0;
          padding: 0;
        }
        #map {
          width: 100%;
          margin-top: 0%;
          height: 100%; /* Full height for the map */
        }
        #charts {
          width: 50%;
          display: flex;
          flex-direction: column;
        }
        .container {
            width: 80%;
            margin: 2rem auto;
            background-color: #fff;
            padding: 2rem;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 1rem 0;
            text-align: center;
        }
        header1 {
          position: absolute;
            top: 50px;
            left: 0;
            background-color:rgba(255, 255, 255, 0.8);
            color: #15a852;
            text-align: center;
            z-index: 1000;
            font-size: 10;font-weight: bold;
        }
        
        
        nav {
            text-align: center;
            padding: 1rem 0;
            background-color: #444;
        }
        nav a {
          color: #28d3ca;
            margin: 0 1rem;
            text-decoration: none;
        }
      
        footer {
            text-align: center;
            padding: 1rem 0;
            background-color: #333;
            color: #fff;
        }
        .tabs {
    list-style: none;
    padding: 0;
    display: flex;
    justify-content: space-around;
    margin-bottom: 10px;
    border-bottom: 1px solid #ccc;
}
.tabs li {
    flex: 1;
}
.tabs a {
    text-decoration: none;
    padding: 10px;
    display: block;
    text-align: center;
    color: #007BFF;
    border-bottom: 2px solid transparent;
}
.tabs a.active {
    border-bottom: 2px solid #007BFF;
    font-weight: bold;
}
.tab-content .tab-pane {
    display: none;
}
.tab-content .tab-pane.active {
    display: block;
}

      </style>



</head>
<body>
  <nav>
    <a href="../index.html">Home</a>
    <a href="../experience.html">Experience</a>
    <a href="../education.html">Education</a>
    <a href="../experience.html">Skills</a>
    <a href="../publications.html">Publications</a>
    <a href="../Jobs.html">Jobs</a>
    <a href="../contact.html">Contact</a>
    <a href="../movies.html">Movies</a>
    <a href="../series.html">Series</a>
    <a href="../nwp_imd.html">NWP_IMD</a>
    <a href="weatherchart.html">weather chart</a>
    <a href="https://www.tropmet.res.in/Careers">IITM career</a>
    <a href="https://vacancies.incois.gov.in/">Incois career</a>

    
</nav>

    <!-- <canvas id="weatherChart" width="400" height="200"></canvas>
    <div id="container" style="width:100%; height:400px;"></div> -->
    <div id="map"></div>
    <header1>
      <h1>Click on a point to find temperature , rainfall and MSLP </h1>
   </header1>

    <script>

document.addEventListener('contextmenu', function(e) { 
    e.preventDefault(); 
}); 
 


document.onkeydown = function(e) { 
    if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && e.key === 'I')) { 
        e.preventDefault(); 
    } 
}; 



let targetLat = 16.5; // Default lat
    let targetLon = 78.4; // Default long
    let place = ''

    // Initialize the Leaflet map
    const map = L.map('map').setView([targetLat, targetLon], 6);

    // Add Google Satellite layer to the map
  

   var googleStreets = L.tileLayer('http://{s}.google.com/vt?lyrs=m&x={x}&y={y}&z={z}',{
    maxZoom: 20,
    subdomains:['mt0','mt1','mt2','mt3']
});


var open=L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap'
    })

    var OpenTopoMap = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
	maxZoom: 17,
	attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
});


 // Define bounds for long (60 to 100)
    const southWest = L.latLng(-90, 60); // Southwest corner (lat, long)
    const northEast = L.latLng(90, 100); // Northeast corner (lat, long)
    const bounds = L.latLngBounds(southWest, northEast);

    // Set the max bounds for the map
    map.setMaxBounds(bounds);


var Stadia_AlidadeSatellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
	attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
		});
var googleHybrid = L.tileLayer('http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}',{
    maxZoom: 20,
    subdomains:['mt0','mt1','mt2','mt3'],
	attribution: '© googleMap'}).addTo(map);

var NASAGIBS_ModisTerraTrueColorCR = L.tileLayer('https://map1.vis.earthdata.nasa.gov/wmts-webmerc/MODIS_Terra_CorrectedReflectance_TrueColor/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}', {
	attribution: 'Imagery provided by services from the Global Imagery Browse Services (GIBS),',
	bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
	minZoom: 1,
	maxZoom: 9,
	format: 'jpg',
	time: '',
	tilematrixset: 'GoogleMapsCompatible_Level'
}).addTo(map);

var NASAGIBS_ModisTerraBands367CR = L.tileLayer('https://map1.vis.earthdata.nasa.gov/wmts-webmerc/MODIS_Terra_CorrectedReflectance_Bands367/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}', {
	attribution: 'Imagery provided by services from the Global Imagery Browse Services (GIBS),',
	bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
	minZoom: 1,
	maxZoom: 9,
	format: 'jpg',
	time: '',
	tilematrixset: 'GoogleMapsCompatible_Level'
});
var NASAGIBS_ppt = L.tileLayer('https://map1.vis.earthdata.nasa.gov/wmts-webmerc/AIRS_Precipitation_Day/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}', {
	attribution: 'Imagery provided by services from the Global Imagery Browse Services (GIBS), operated by the NASA/GSFC/Earth Science Data and Information System.',
	bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
	minZoom: 1,
	maxZoom: 6,
	format: 'png',
	time: '',
	tilematrixset: 'GoogleMapsCompatible_Level'
});

var IMERG_ppt = L.tileLayer('https://map1.vis.earthdata.nasa.gov/wmts-webmerc/IMERG_Precipitation_Rate/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}', {
	attribution: 'Imagery provided by services from the Global Imagery Browse Services (GIBS), operated by the NASA/GSFC/Earth Science Data and Information System.',
	bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
	minZoom: 1,
	maxZoom: 6,
	format: 'png',
	time: '',
	tilematrixset: 'GoogleMapsCompatible_Level'
});

var SURFACE_ppt = L.tileLayer('https://map1.vis.earthdata.nasa.gov/wmts-webmerc/AMSRU2_Surface_Precipitation_Day/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}', {
	attribution: 'Imagery provided by services from the Global Imagery Browse Services (GIBS), operated by the NASA/GSFC/Earth Science Data and Information System.',
	bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
	minZoom: 1,
	maxZoom: 6,
	format: 'png',
	time: '',
	tilematrixset: 'GoogleMapsCompatible_Level'
});



var NASAGIBS_ModisTerraLSTDay = L.tileLayer('https://map1.vis.earthdata.nasa.gov/wmts-webmerc/MODIS_Terra_Land_Surface_Temp_Day/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}', {
	attribution: 'Imagery provided by services from the Global Imagery Browse Services (GIBS)',
	bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
	minZoom: 1,
	maxZoom: 7,
	format: 'png',
	time: '',
	tilematrixset: 'GoogleMapsCompatible_Level',
	opacity: 0.75
});
var NASAGIBS_ModisTerraSnowCover = L.tileLayer('https://map1.vis.earthdata.nasa.gov/wmts-webmerc/MODIS_Terra_NDSI_Snow_Cover/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}', {
	attribution: 'Imagery provided by services from the Global Imagery Browse Services (GIBS),',
	bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
	minZoom: 1,
	maxZoom: 8,
	format: 'png',
	time: '',
	tilematrixset: 'GoogleMapsCompatible_Level',
	opacity: 0.75
});


var NASAGIBS_ModisTerraAOD = L.tileLayer('https://map1.vis.earthdata.nasa.gov/wmts-webmerc/MODIS_Terra_Aerosol/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}', {
	attribution: 'Imagery provided by services from the Global Imagery Browse Services (GIBS),',
	bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
	minZoom: 1,
	maxZoom: 6,
	format: 'png',
	time: '',
	tilematrixset: 'GoogleMapsCompatible_Level',
	opacity: 0.75
});
var NASAGIBS_ModisTerraChlorophyll = L.tileLayer('https://map1.vis.earthdata.nasa.gov/wmts-webmerc/MODIS_Terra_L2_Chlorophyll_A/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}', {
	attribution: 'Imagery provided by services from the Global Imagery Browse Services (GIBS),',
	bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
	minZoom: 1,
	maxZoom: 7,
	format: 'png',
	time: '',
	tilematrixset: 'GoogleMapsCompatible_Level',
	opacity: 0.75
});

var googleHybrid = L.tileLayer('http://{s}.google.com/vt?lyrs=s,h&x={x}&y={y}&z={z}',{
    maxZoom: 20,
    subdomains:['mt0','mt1','mt2','mt3']
});


    var googleSat = L.tileLayer('http://{s}.google.com/vt?lyrs=s&x={x}&y={y}&z={z}',{
    maxZoom: 20,
    subdomains:['mt0','mt1','mt2','mt3']
});
// var india = new L.GeoJSON('IND.json');


// const uniqueContainerId = 'container-temp-' + Date.now();
// const uniqueContainerId1 = 'container-rf-' + Date.now();


// var popupContent = `
//     <div>
//         <strong>Coordinates:</strong> ${targetLat}, ${targetLon}
//         <div id="${uniqueContainerId}" style="width:100%; height:400px;"></div>
//         <div id="${uniqueContainerId1}" style="width:100%; height:400px;"></div>

//     </div>`;





var googleTerrain = L.tileLayer('http://{s}.google.com/vt?lyrs=p&x={x}&y={y}&z={z}',{
    maxZoom: 20,
    subdomains:['mt0','mt1','mt2','mt3']
}).addTo(map);






var baseMaps={
    'OSM':open,
    'topo': OpenTopoMap,
    'STADIA':Stadia_AlidadeSatellite,
	'google':googleHybrid,
'street':googleStreets,
'Hybrid':googleHybrid,


};
var overlays={
    'terra':NASAGIBS_ModisTerraBands367CR,
    'truecolor': NASAGIBS_ModisTerraTrueColorCR,
    'snow':NASAGIBS_ModisTerraSnowCover,
    'LST':NASAGIBS_ModisTerraLSTDay,
    'AOD':NASAGIBS_ModisTerraAOD,
    'CHLOROPHYL':NASAGIBS_ModisTerraChlorophyll,
    // 'RAIN':NASAGIBS_ppt,
    'IMERG':IMERG_ppt,
    'SURFACE PPT':SURFACE_ppt
};








L.control.layers(baseMaps, overlays).addTo(map);
var markers = [];






function findNearestIndex(value, array) {
    const exactIndex = array.indexOf(value);
    if (exactIndex !== -1) {
    return exactIndex;
        } else {
        // If exact match is not found, find the nearest index
        let nearestIndex = 0;
        let minDiff = Math.abs(value - array[0]);
        for (let i = 1; i < array.length; i++) {
        const diff = Math.abs(value - array[i]);
        if (diff < minDiff) {
        minDiff = diff;
        nearestIndex = i;
        }
        }
        if (minDiff > 5) {
        return null;
        }
        return nearestIndex;
        }
    }


function getTemperatureData(targetLat, targetLon) {
  return fetch('temp_tot_nasa.json')
    .then(response => {
      if (!response.ok) {
        throw new Error("Network response was not ok");
      }
      return response.json();
    })
    .then(data => {
      if (data.data) {
        console.log(data)
        const temperatureData = data.data;

        const latArray = data.coords.lat.data;
        const lonArray = data.coords.lon.data;

        const nearestLatIndex = findNearestIndex(targetLat, latArray);
        const nearestLonIndex = findNearestIndex(targetLon, lonArray);

        const lon1 = lonArray[nearestLonIndex];
        const lat1 = latArray[nearestLatIndex];

        // Extract the first 100 values for time and temperature
        const labels = (data.coords.time.data || [])//.slice(0, 72); // Limit to first 100 values
        
        // Map the temperature data to Celsius
        const chartData = (temperatureData || []).map(row => {
          const tempInCelsius = row[nearestLatIndex][nearestLonIndex] - 273.15;
          return parseFloat(tempInCelsius.toFixed(2)); // Round to 2 decimal places
        })

        // Return the chartData
        return {
          labels: labels,
          temperatures: chartData
        };
      } else {
        throw new Error("No temperature data available");
      }
    })
    .catch(error => {
      console.error("Error fetching temperature data:", error);
      return []; // Return an empty array or handle the error as needed
    });
}


function getcloudData(targetLat, targetLon) {
  return fetch('cloud_tot_nasa.json')
    .then(response => {
      if (!response.ok) {
        throw new Error("Network response was not ok");
      }
      return response.json();
    })
    .then(data => {
      if (data.data) {
        console.log(data)
        const temperatureData = data.data;

        const latArray = data.coords.lat.data;
        const lonArray = data.coords.lon.data;

        const nearestLatIndex = findNearestIndex(targetLat, latArray);
        const nearestLonIndex = findNearestIndex(targetLon, lonArray);

        const lon1 = lonArray[nearestLonIndex];
        const lat1 = latArray[nearestLatIndex];

        // Extract the first 100 values for time and temperature
        const labels = (data.coords.time.data || [])//.slice(0, 72); // Limit to first 100 values
        
        // Map the temperature data to Celsius
        const chartData = (temperatureData || []).map(row => {
          const tempInCelsius = row[nearestLatIndex][nearestLonIndex];
          return parseFloat(tempInCelsius.toFixed(2)); // Round to 2 decimal places
        })

        // Return the chartData
        return {
          labels: labels,
          clouds: chartData
        };
      } else {
        throw new Error("No temperature data available");
      }
    })
    .catch(error => {
      console.error("Error fetching temperature data:", error);
      return []; // Return an empty array or handle the error as needed
    });
}





function getrfData(targetLat, targetLon) {
  return fetch('rf_tot_nasa.json')
    .then(response => {
      if (!response.ok) {
        throw new Error("Network response was not ok");
      }
      return response.json();
    })
    .then(data => {
      if (data.data) {
        const temperatureData = data.data;

        const latArray = data.coords.lat.data;
        const lonArray = data.coords.lon.data;

        const nearestLatIndex = findNearestIndex(targetLat, latArray);
        const nearestLonIndex = findNearestIndex(targetLon, lonArray);

        const lon1 = lonArray[nearestLonIndex];
        const lat1 = latArray[nearestLatIndex];

        
        // Map the temperature data to Celsius
        const chartData = (temperatureData || []).map(row => {
          const tempInCelsius = row[nearestLatIndex][nearestLonIndex];
          return parseFloat(tempInCelsius.toFixed(0)); // Round to 2 decimal places
        })
        // Return the chartData
        return {
          rf: chartData
        };
      } else {
        throw new Error("No temperature data available");
      }
    })
    .catch(error => {
      console.error("Error fetching temperature data:", error);
      return []; // Return an empty array or handle the error as needed
    });
}


function getmslData(targetLat, targetLon) {
  return fetch('mslp_tot_nasa.json')
    .then(response => {
      if (!response.ok) {
        throw new Error("Network response was not ok");
      }
      return response.json();
    })
    .then(data => {
      if (data.data) {
        const temperatureData = data.data;

        const latArray = data.coords.lat.data;
        const lonArray = data.coords.lon.data;

        const nearestLatIndex = findNearestIndex(targetLat, latArray);
        const nearestLonIndex = findNearestIndex(targetLon, lonArray);

        const lon1 = lonArray[nearestLonIndex];
        const lat1 = latArray[nearestLatIndex];

        // Extract the first 100 values for time and temperature
        
        // Map the temperature data to Celsius
        const chartData = (temperatureData || []).map(row => {
          const tempInCelsius = row[nearestLatIndex][nearestLonIndex];
          return parseFloat(tempInCelsius.toFixed(2)); // Round to 2 decimal places
        })
        // Return the chartData
        return {
          msl: chartData
        };
      } else {
        throw new Error("No temperature data available");
      }
    })
    .catch(error => {
      console.error("Error fetching temperature data:", error);
      return []; // Return an empty array or handle the error as needed
    });
}




function getdata(targetLat, targetLon,file) {
  return fetch(file)
    .then(response => {
      if (!response.ok) {
        throw new Error("Network response was not ok");
      }
      return response.json();
    })
    .then(data => {
      if (data.data) {
        console.log(data)
        const temperatureData = data.data;

        const latArray = data.coords.latitude.data;
        const lonArray = data.coords.longitude.data;

        const nearestLatIndex = findNearestIndex(targetLat, latArray);
        const nearestLonIndex = findNearestIndex(targetLon, lonArray);

        const lon1 = lonArray[nearestLonIndex];
        const lat1 = latArray[nearestLatIndex];

        // Extract the first 100 values for time and temperature
        const labels = (data.coords.step.data || [])//.slice(0, 72); // Limit to first 100 values
        
        // Map the temperature data to Celsius
        const chartData = (temperatureData || []).map(row => {
          const tempInCelsius = row[nearestLatIndex][nearestLonIndex];
          return parseFloat(tempInCelsius.toFixed(2)); // Round to 2 decimal places
        })

        // Return the chartData
        return {
          labels: labels,
          var: chartData
        };
      } else {
        throw new Error("No temperature data available");
      }
    })
    .catch(error => {
      console.error("Error fetching temperature data:", error);
      return []; // Return an empty array or handle the error as needed
    });
}


// const checkDebugger = setInterval(() => {
//     const devtools = /./;
//     devtools.toString = function() {
//       clearInterval(checkDebugger);
//       alert("Debugger is open. Closing the page.");
//       window.close(); // Attempt to close the page
//     };
//     console.log(devtools); // This will trigger the above function if the debugger is open
//   }, 1000); // Check every second

function createWeatherChartecmwf( targetLat, targetLon,container) {

Promise.all([
  getdata(targetLat, targetLon,'2m_temp.json'),
  getdata(targetLat, targetLon,'rf.json'),
  getdata(targetLat, targetLon,'msl.json'),
  getdata(targetLat, targetLon,'tcwv.json')
  
])
.then(([tempData, rainData,msldata,clouddata]) => {
  // Extracting time, temperatures, and rainfall
  const time = tempData.labels; // Extracted time
  const temperatures = tempData.var; // Extracted temperatures
  const rainfall = rainData.var; // Extracted rainfall
  const mslp = msldata.var; // Extracted rainfall
  const cloud  = clouddata.var; // Extracted rainfall
  


  const localTime = time.map(gmtTime => {
      const date = new Date(gmtTime); // Parse the GMT time
      date.setHours(date.getHours() + 5); // Add 5 hours
      date.setMinutes(date.getMinutes() + 30); // Add 30 minutes

      // Get day name
      const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      const dayName = days[date.getDay()]; // Get day name

      // Format day, month, and hour
      const day = String(date.getDate()).padStart(2, '0'); // Get day and pad with zero
      const month = String(date.getMonth() + 1).padStart(2, '0'); // Get month (0-indexed) and pad
      let hour = date.getHours(); // Get hour
      const ampm = hour >= 12 ? 'PM' : 'AM'; // Determine AM/PM
      hour = hour % 12; // Convert to 12-hour format
      hour = hour ? String(hour).padStart(2, '0') : '12'; // Pad with zero or set to 12

      return `${dayName}, ${day}-${month}-2024 ${hour}:00 ${ampm}`; // Return formatted string
    });



  var tempchart= Highcharts.chart(container, {
              chart: {
                type: 'line'
              },
              title: {
                  text: `` ,
                  style: {
        fontSize: '12px' 
     }
                  // at ${ place ||  `Lat: ${latArray[nearestLatIndex]}, Lon: ${lonArray[nearestLonIndex]}`
              },
                xAxis: {
               categories: localTime,

               type: 'datetime',
            tickInterval: 12* 1, // two hours
            
            labels: {
                format: '{value:%b}'
            },
               title: {
                 text: 'Time',
                 
               }
             },
             yAxis: [{
                title: {
                    text: 'Temperature()',
                    style: {
                        color: ' #ff531a',
                    }
                },
                labels: {
                    style: {
                        color: '#ff531a' // Set the color of the tick labels to blue
                    }
                }
            }, 
            {
                title: {
                    text: 'Pressure',
                    style: {
                        color: '#1a75ff'
                    }
                },
                opposite: true, // Position the second axis on the opposite side
                labels: {
                    style: {
                        color: '#1a75ff' // Set the color of the tick labels to blue
                    }
                }
            },
            {
                title: {
                    text: 'Cloud cover (%)',
                    style: {
                        color: '#c83e9d'
                    }
                },
                opposite: true, // Position the second axis on the opposite side
                labels: {
                    style: {
                        color: '#c83e9d' // Set the color of the tick labels to blue
                    }
                }
            },

            {
                title: {
        text: 'Rainfall (mm/3hr)',
        style: {
          color: '#00cc00'
        }
      },
      opposite: false, // Keep it on the default side
       labels: {
                    style: {
                        color: '#00cc00' // Set the color of the tick labels to blue
                    }
                }

    }
],
            
              series: [
              {
                name: 'Temperature',
                data: temperatures,
                color: ' #ff531a',
                marker: {
                    enabled: false // Disable markers for this series
                }
              }  
              , 
              {
                name: 'Pressure',
                data: mslp,
                color: '#1a75ff',
                yAxis : 1,dashStyle: 'ShortDash'
                ,marker: {
                    enabled: false // Disable markers for this series
                }
              }  
              , {
                name: 'Rainfall (mm/3hr)',
                data: rainfall,
                color: '#00cc00',
                yAxis : 3,
                type: 'column'
                ,marker: {
                    enabled: false // Disable markers for this series
                }
                
              }
              
              ,{
                name: 'Total cloud cover  (%)',
                data: cloud,
                color: '#c83e9d',
                yAxis : 2,
                type: 'line'
                
              }  

              
          ],
          subtitle: {
        text: 'Disclaimer: This is not a Official forecast. Data is for informational purposes only.'
      },
          tooltip: {
    shared: true, // Enables a shared tooltip for all series
    formatter: function () {
      let tooltip = `<b>Time:</b> ${this.x}<br>`;
      this.points.forEach(point => {
        tooltip += `<span style="color:${point.color}">\u25CF</span> <b>${point.series.name}:</b> ${point.y}<br>`;
      });
      return tooltip;
    }
  },
              responsive: {
                rules: [{
                  condition: {
                    maxWidth: 500
                  },
                  chartOptions: {
                    legend: {
                      enabled: false
                    }
                  }
                }]
              }
            });

const highTempThreshold = 30;
const exceededTemps = temperatures.filter(temp => temp > highTempThreshold);

const highrfThreshold = 10;
const exceededrf = rainfall.filter(temp => temp > highrfThreshold);

const mintempThreshold = 10;
const exceededte = temperatures.filter(temp => temp <= mintempThreshold);


const lowmslThreshold = 1000;
const exceededlow = mslp.filter(temp => temp < lowmslThreshold);
let alertMessage = '';





if (exceededTemps.length > 0) {
  alertMessage += `Temperature has crossed above ${highTempThreshold}°C! `;
}

if (exceededte.length > 0) {
  alertMessage += `Temperature has crossed below ${mintempThreshold}°C! `;
}


if (exceededrf.length > 0) {
  alertMessage += `Rainfall has crossed ${highrfThreshold} mm!`;
}

if (exceededlow.length > 0) {
  alertMessage += `MSLP has crossed below  ${lowmslThreshold} mm!`;
}


// Show alert if any condition is satisfied


console.log("Alert Message:", alertMessage);
if (alertMessage) {
      alert(`Alert: ${alertMessage}`);
    }





})
.catch(error => {
  console.error("Error:", error);
})};



function createWeatherChart( targetLat, targetLon,container) {

Promise.all([
  getTemperatureData(targetLat, targetLon),
  getrfData(targetLat, targetLon),
  getmslData(targetLat, targetLon),
  getcloudData(targetLat, targetLon)
])
.then(([tempData, rainData,msldata,clouddata]) => {
  // Extracting time, temperatures, and rainfall
  const time = tempData.labels; // Extracted time
  const temperatures = tempData.temperatures; // Extracted temperatures
  const rainfall = rainData.rf; // Extracted rainfall
  const mslp = msldata.msl; // Extracted rainfall
  const cloud  = clouddata.clouds; // Extracted rainfall
  
  const localTime = time.map(gmtTime => {
      const date = new Date(gmtTime); // Parse the GMT time
      date.setHours(date.getHours() + 5); // Add 5 hours
      date.setMinutes(date.getMinutes() + 30); // Add 30 minutes

      // Get day name
      const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      const dayName = days[date.getDay()]; // Get day name

      // Format day, month, and hour
      const day = String(date.getDate()).padStart(2, '0'); // Get day and pad with zero
      const month = String(date.getMonth() + 1).padStart(2, '0'); // Get month (0-indexed) and pad
      let hour = date.getHours(); // Get hour
      const ampm = hour >= 12 ? 'PM' : 'AM'; // Determine AM/PM
      hour = hour % 12; // Convert to 12-hour format
      hour = hour ? String(hour).padStart(2, '0') : '12'; // Pad with zero or set to 12

      return `${dayName}, ${day}-${month}-2024 ${hour}:00 ${ampm}`; // Return formatted string
    });



  var tempchart= Highcharts.chart(container, {
              chart: {
                type: 'line'
              },
              title: {
                  text: `` ,
                  style: {
        fontSize: '12px' 
     }
                  // at ${ place ||  `Lat: ${latArray[nearestLatIndex]}, Lon: ${lonArray[nearestLonIndex]}`
              },
                xAxis: {
               categories: localTime,

               type: 'datetime',
            tickInterval: 12* 1, // two hours
            
            labels: {
                format: '{value:%b}'
            },
               title: {
                 text: 'Time',
                 
               }
             },
             yAxis: [{
                title: {
                    text: 'Temperature()',
                    style: {
                        color: ' #ff531a',
                    }
                },
                labels: {
                    style: {
                        color: '#ff531a' // Set the color of the tick labels to blue
                    }
                }
            }, 
            {
                title: {
                    text: 'Pressure',
                    style: {
                        color: '#1a75ff'
                    }
                },
                opposite: true, // Position the second axis on the opposite side
                labels: {
                    style: {
                        color: '#1a75ff' // Set the color of the tick labels to blue
                    }
                }
            },
            {
                title: {
                    text: 'Cloud cover (%)',
                    style: {
                        color: '#c83e9d'
                    }
                },
                opposite: true, // Position the second axis on the opposite side
                labels: {
                    style: {
                        color: '#c83e9d' // Set the color of the tick labels to blue
                    }
                }
            },

            {
                title: {
        text: 'Rainfall (mm/3hr)',
        style: {
          color: '#00cc00'
        }
      },
      opposite: false, // Keep it on the default side
       labels: {
                    style: {
                        color: '#00cc00' // Set the color of the tick labels to blue
                    }
                }

    }
],
            
              series: [
              {
                name: 'Temperature',
                data: temperatures,
                color: ' #ff531a',
                marker: {
                    enabled: false // Disable markers for this series
                }
              }  
              , 
              {
                name: 'Pressure',
                data: mslp,
                color: '#1a75ff',
                yAxis : 1,dashStyle: 'ShortDash'
                ,marker: {
                    enabled: false // Disable markers for this series
                }
              }  
              , {
                name: 'Rainfall (mm/3hr)',
                data: rainfall,
                color: '#00cc00',
                yAxis : 3,
                type: 'column'
                ,marker: {
                    enabled: false // Disable markers for this series
                }
                
              }
              
              ,{
                name: 'Total cloud cover  (%)',
                data: cloud,
                color: '#c83e9d',
                yAxis : 2,
                type: 'line'
                
              }  

              
          ],
          subtitle: {
        text: 'Disclaimer: This is not a Official forecast. Data is for informational purposes only.'
      },
          tooltip: {
    shared: true, // Enables a shared tooltip for all series
    formatter: function () {
      let tooltip = `<b>Time:</b> ${this.x}<br>`;
      this.points.forEach(point => {
        tooltip += `<span style="color:${point.color}">\u25CF</span> <b>${point.series.name}:</b> ${point.y}<br>`;
      });
      return tooltip;
    }
  },
              responsive: {
                rules: [{
                  condition: {
                    maxWidth: 500
                  },
                  chartOptions: {
                    legend: {
                      enabled: false
                    }
                  }
                }]
              }
            });

const highTempThreshold = 30;
const exceededTemps = temperatures.filter(temp => temp > highTempThreshold);

const highrfThreshold = 10;
const exceededrf = rainfall.filter(temp => temp > highrfThreshold);

const mintempThreshold = 10;
const exceededte = temperatures.filter(temp => temp <= mintempThreshold);


const lowmslThreshold = 1000;
const exceededlow = mslp.filter(temp => temp < lowmslThreshold);
let alertMessage = '';





if (exceededTemps.length > 0) {
  alertMessage += `Temperature has crossed above ${highTempThreshold}°C! `;
}

if (exceededte.length > 0) {
  alertMessage += `Temperature has crossed below ${mintempThreshold}°C! `;
}


if (exceededrf.length > 0) {
  alertMessage += `Rainfall has crossed ${highrfThreshold} mm!`;
}

if (exceededlow.length > 0) {
  alertMessage += `MSLP has crossed below  ${lowmslThreshold} mm!`;
}


// Show alert if any condition is satisfied


console.log("Alert Message:", alertMessage);
if (alertMessage) {
      alert(`Alert: ${alertMessage}`);
    }





})
.catch(error => {
  console.error("Error:", error);
})};

map.on('click', function (e) {
    const targetLat = parseFloat(e.latlng.lat.toFixed(2));
    const targetLon = parseFloat(e.latlng.lng.toFixed(2));
    const uniqueId = Date.now(); // Unique ID for popup content

    // Create tabs and content dynamically
    const popupContent = `
        <div style="text-align: center; width: 900px;">
            <strong>Coordinates:</strong> ${targetLat}, ${targetLon}
            <ul class="nav nav-tabs" role="tablist">
                <li class="nav-item">
                    <a class="nav-link active" data-bs-toggle="tab" href="#temp-${uniqueId}" role="tab">NOAA-GFS</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" data-bs-toggle="tab" href="#rain-${uniqueId}" role="tab">ECMWF-OPENDATA</a>
                </li>
                
            </ul>
            <div class="tab-content mt-3">
                <div class="tab-pane fade show active" id="temp-${uniqueId}" role="tabpanel" style="width: 900px; height: 400px;"></div>
                <div class="tab-pane fade" id="rain-${uniqueId}" role="tabpanel" style="width: 900px; height: 400px;"></div>
                
            </div>
        </div>`;

    // Remove existing markers
    markers.forEach(function (marker) {
        map.removeLayer(marker);
    });
    markers = [];

    // Add marker
    const marker = L.marker([targetLat, targetLon]).addTo(map);

    // Bind the popup content to the marker
    marker.bindPopup(popupContent, { maxWidth: 900, maxHeight: 400 });

    // Open the popup manually and wait for it to fully render
    marker.openPopup();

    // Add a delay to ensure the popup content is rendered
    setTimeout(() => {
        console.log("Popup opened. Waiting for DOM to render...");

        // Initialize charts in each tab
        const tempContainer = document.getElementById(`temp-${uniqueId}`);
        const rainContainer = document.getElementById(`rain-${uniqueId}`);
        // const mslContainer = document.getElementById(`msl-${uniqueId}`);
        // const tcwvContainer = document.getElementById(`tcwv-${uniqueId}`);

        if (tempContainer && rainContainer ) {
            console.log("All containers are available. Proceeding with plotting...");
            // createWeatherChart(targetLat, targetLon, `temp-${uniqueId}`); // Temperature chart
            createWeatherChartecmwf(targetLat, targetLon, `rain-${uniqueId}`); // Rainfall chart



            
        } else {
            console.error("Popup content not fully rendered. Containers not found in the DOM.");
        }
    }, 3); // Adjust delay as necessary

    // Save marker for later removal
    markers.push(marker);
});


// JavaScript/CSS for Tabs
document.addEventListener('click', (event) => {
    if (event.target.classList.contains('tab-link')) {
        event.preventDefault();
        const allLinks = document.querySelectorAll('.tab-link');
        const allPanes = document.querySelectorAll('.tab-pane');

        // Deactivate all tabs and panes
        allLinks.forEach(link => link.classList.remove('active'));
        allPanes.forEach(pane => pane.classList.remove('active'));

        // Activate the clicked tab and corresponding pane
        event.target.classList.add('active');
        const targetPane = document.querySelector(event.target.getAttribute('href'));
        if (targetPane) {
            targetPane.classList.add('active');
        }
    }
});

  
    </script>
</body>
</html>
